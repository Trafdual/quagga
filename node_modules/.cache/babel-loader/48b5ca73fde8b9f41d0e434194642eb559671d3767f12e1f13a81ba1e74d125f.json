{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useCallback, useLayoutEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport Quagga from '@ericblade/quagga2';\nfunction getMedian(arr) {\n  const newArr = [...arr]; // copy the array before sorting, otherwise it mutates the array passed in, which is generally undesireable\n  newArr.sort((a, b) => a - b);\n  const half = Math.floor(newArr.length / 2);\n  if (newArr.length % 2 === 1) {\n    return newArr[half];\n  }\n  return (newArr[half - 1] + newArr[half]) / 2;\n}\nfunction getMedianOfCodeErrors(decodedCodes) {\n  const errors = decodedCodes.flatMap(x => x.error);\n  const medianOfErrors = getMedian(errors);\n  return medianOfErrors;\n}\nconst defaultConstraints = {\n  width: 640,\n  height: 480\n};\nconst defaultLocatorSettings = {\n  patchSize: 'medium',\n  halfSample: true,\n  willReadFrequently: true\n};\nconst defaultDecoders = ['ean_reader'];\nconst Scanner = _ref => {\n  _s();\n  let {\n    onDetected,\n    scannerRef,\n    onScannerReady,\n    cameraId,\n    facingMode,\n    constraints = defaultConstraints,\n    locator = defaultLocatorSettings,\n    decoders = defaultDecoders,\n    locate = true\n  } = _ref;\n  const errorCheck = useCallback(result => {\n    if (!onDetected) {\n      return;\n    }\n    const err = getMedianOfCodeErrors(result.codeResult.decodedCodes);\n    // if Quagga is at least 75% certain that it read correctly, then accept the code.\n    if (err < 0.25) {\n      onDetected(result.codeResult.code);\n    }\n  }, [onDetected]);\n  const handleProcessed = result => {\n    const drawingCtx = Quagga.canvas.ctx.overlay;\n    const drawingCanvas = Quagga.canvas.dom.overlay;\n    drawingCtx.font = \"24px Arial\";\n    drawingCtx.fillStyle = 'green';\n    if (result) {\n      // console.warn('* quagga onProcessed', result);\n      if (result.boxes) {\n        drawingCtx.clearRect(0, 0, parseInt(drawingCanvas.getAttribute('width')), parseInt(drawingCanvas.getAttribute('height')));\n        result.boxes.filter(box => box !== result.box).forEach(box => {\n          Quagga.ImageDebug.drawPath(box, {\n            x: 0,\n            y: 1\n          }, drawingCtx, {\n            color: 'purple',\n            lineWidth: 2\n          });\n        });\n      }\n      if (result.box) {\n        Quagga.ImageDebug.drawPath(result.box, {\n          x: 0,\n          y: 1\n        }, drawingCtx, {\n          color: 'blue',\n          lineWidth: 2\n        });\n      }\n      if (result.codeResult && result.codeResult.code) {\n        // const validated = barcodeValidator(result.codeResult.code);\n        // const validated = validateBarcode(result.codeResult.code);\n        // Quagga.ImageDebug.drawPath(result.line, { x: 'x', y: 'y' }, drawingCtx, { color: validated ? 'green' : 'red', lineWidth: 3 });\n        drawingCtx.font = \"24px Arial\";\n        // drawingCtx.fillStyle = validated ? 'green' : 'red';\n        // drawingCtx.fillText(`${result.codeResult.code} valid: ${validated}`, 10, 50);\n        drawingCtx.fillText(result.codeResult.code, 10, 20);\n        // if (validated) {\n        //     onDetected(result);\n        // }\n      }\n    }\n  };\n\n  useLayoutEffect(() => {\n    // if this component gets unmounted in the same tick that it is mounted, then all hell breaks loose,\n    // so we need to wait 1 tick before calling init().  I'm not sure how to fix that, if it's even possible,\n    // given the asynchronous nature of the camera functions, the non asynchronous nature of React, and just how\n    // awful browsers are at dealing with cameras.\n    let ignoreStart = false;\n    const init = async () => {\n      // wait for one tick to see if we get unmounted before we can possibly even begin cleanup\n      await new Promise(resolve => setTimeout(resolve, 1));\n      if (ignoreStart) {\n        return;\n      }\n      // begin scanner initialization\n      await Quagga.init({\n        inputStream: {\n          type: 'LiveStream',\n          constraints: {\n            ...constraints,\n            ...(cameraId && {\n              deviceId: cameraId\n            }),\n            ...(!cameraId && {\n              facingMode\n            })\n          },\n          target: scannerRef.current,\n          willReadFrequently: true\n        },\n        locator,\n        decoder: {\n          readers: decoders\n        },\n        locate\n      }, async err => {\n        Quagga.onProcessed(handleProcessed);\n        if (err) {\n          return console.error('Error starting Quagga:', err);\n        }\n        if (scannerRef && scannerRef.current) {\n          await Quagga.start();\n          if (onScannerReady) {\n            onScannerReady();\n          }\n        }\n      });\n      Quagga.onDetected(errorCheck);\n    };\n    init();\n    // cleanup by turning off the camera and any listeners\n    return () => {\n      ignoreStart = true;\n      Quagga.stop();\n      Quagga.offDetected(errorCheck);\n      Quagga.offProcessed(handleProcessed);\n    };\n  }, [cameraId, onDetected, onScannerReady, scannerRef, errorCheck, constraints, locator, decoders, locate, facingMode]);\n  return null;\n};\n_s(Scanner, \"i8A3h1IH7wCRvhnx9DLDqWoZqPM=\");\n_c = Scanner;\nScanner.propTypes = {\n  onDetected: PropTypes.func.isRequired,\n  scannerRef: PropTypes.object.isRequired,\n  onScannerReady: PropTypes.func,\n  cameraId: PropTypes.string,\n  facingMode: PropTypes.string,\n  constraints: PropTypes.object,\n  locator: PropTypes.object,\n  decoders: PropTypes.array,\n  locate: PropTypes.bool\n};\nexport default Scanner;\nvar _c;\n$RefreshReg$(_c, \"Scanner\");","map":{"version":3,"names":["useCallback","useLayoutEffect","PropTypes","Quagga","getMedian","arr","newArr","sort","a","b","half","Math","floor","length","getMedianOfCodeErrors","decodedCodes","errors","flatMap","x","error","medianOfErrors","defaultConstraints","width","height","defaultLocatorSettings","patchSize","halfSample","willReadFrequently","defaultDecoders","Scanner","_ref","_s","onDetected","scannerRef","onScannerReady","cameraId","facingMode","constraints","locator","decoders","locate","errorCheck","result","err","codeResult","code","handleProcessed","drawingCtx","canvas","ctx","overlay","drawingCanvas","dom","font","fillStyle","boxes","clearRect","parseInt","getAttribute","filter","box","forEach","ImageDebug","drawPath","y","color","lineWidth","fillText","ignoreStart","init","Promise","resolve","setTimeout","inputStream","type","deviceId","target","current","decoder","readers","onProcessed","console","start","stop","offDetected","offProcessed","_c","propTypes","func","isRequired","object","string","array","bool","$RefreshReg$"],"sources":["D:/neworking/quagga2-react-example/src/Scanner.js"],"sourcesContent":["import { useCallback, useLayoutEffect } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Quagga from '@ericblade/quagga2';\r\n\r\nfunction getMedian(arr) {\r\n    const newArr = [...arr]; // copy the array before sorting, otherwise it mutates the array passed in, which is generally undesireable\r\n    newArr.sort((a, b) => a - b);\r\n    const half = Math.floor(newArr.length / 2);\r\n    if (newArr.length % 2 === 1) {\r\n        return newArr[half];\r\n    }\r\n    return (newArr[half - 1] + newArr[half]) / 2;\r\n}\r\n\r\nfunction getMedianOfCodeErrors(decodedCodes) {\r\n    const errors = decodedCodes.flatMap(x => x.error);\r\n    const medianOfErrors = getMedian(errors);\r\n    return medianOfErrors;\r\n}\r\n\r\nconst defaultConstraints = {\r\n    width: 640,\r\n    height: 480,\r\n};\r\n\r\nconst defaultLocatorSettings = {\r\n    patchSize: 'medium',\r\n    halfSample: true,\r\n    willReadFrequently: true,\r\n};\r\n\r\nconst defaultDecoders = ['ean_reader'];\r\n\r\nconst Scanner = ({\r\n    onDetected,\r\n    scannerRef,\r\n    onScannerReady,\r\n    cameraId,\r\n    facingMode,\r\n    constraints = defaultConstraints,\r\n    locator = defaultLocatorSettings,\r\n    decoders = defaultDecoders,\r\n    locate = true,\r\n}) => {\r\n    const errorCheck = useCallback((result) => {\r\n        if (!onDetected) {\r\n            return;\r\n        }\r\n        const err = getMedianOfCodeErrors(result.codeResult.decodedCodes);\r\n        // if Quagga is at least 75% certain that it read correctly, then accept the code.\r\n        if (err < 0.25) {\r\n            onDetected(result.codeResult.code);\r\n        }\r\n    }, [onDetected]);\r\n\r\n    const handleProcessed = (result) => {\r\n        const drawingCtx = Quagga.canvas.ctx.overlay;\r\n        const drawingCanvas = Quagga.canvas.dom.overlay;\r\n        drawingCtx.font = \"24px Arial\";\r\n        drawingCtx.fillStyle = 'green';\r\n\r\n        if (result) {\r\n            // console.warn('* quagga onProcessed', result);\r\n            if (result.boxes) {\r\n                drawingCtx.clearRect(0, 0, parseInt(drawingCanvas.getAttribute('width')), parseInt(drawingCanvas.getAttribute('height')));\r\n                result.boxes.filter((box) => box !== result.box).forEach((box) => {\r\n                    Quagga.ImageDebug.drawPath(box, { x: 0, y: 1 }, drawingCtx, { color: 'purple', lineWidth: 2 });\r\n                });\r\n            }\r\n            if (result.box) {\r\n                Quagga.ImageDebug.drawPath(result.box, { x: 0, y: 1 }, drawingCtx, { color: 'blue', lineWidth: 2 });\r\n            }\r\n            if (result.codeResult && result.codeResult.code) {\r\n                // const validated = barcodeValidator(result.codeResult.code);\r\n                // const validated = validateBarcode(result.codeResult.code);\r\n                // Quagga.ImageDebug.drawPath(result.line, { x: 'x', y: 'y' }, drawingCtx, { color: validated ? 'green' : 'red', lineWidth: 3 });\r\n                drawingCtx.font = \"24px Arial\";\r\n                // drawingCtx.fillStyle = validated ? 'green' : 'red';\r\n                // drawingCtx.fillText(`${result.codeResult.code} valid: ${validated}`, 10, 50);\r\n                drawingCtx.fillText(result.codeResult.code, 10, 20);\r\n                // if (validated) {\r\n                //     onDetected(result);\r\n                // }\r\n            }\r\n        }\r\n    };\r\n\r\n    useLayoutEffect(() => {\r\n        // if this component gets unmounted in the same tick that it is mounted, then all hell breaks loose,\r\n        // so we need to wait 1 tick before calling init().  I'm not sure how to fix that, if it's even possible,\r\n        // given the asynchronous nature of the camera functions, the non asynchronous nature of React, and just how\r\n        // awful browsers are at dealing with cameras.\r\n        let ignoreStart = false;\r\n        const init = async () => {\r\n            // wait for one tick to see if we get unmounted before we can possibly even begin cleanup\r\n            await new Promise((resolve) => setTimeout(resolve, 1));\r\n            if (ignoreStart) {\r\n                return;\r\n            }\r\n            // begin scanner initialization\r\n            await Quagga.init({\r\n                inputStream: {\r\n                    type: 'LiveStream',\r\n                    constraints: {\r\n                        ...constraints,\r\n                        ...(cameraId && { deviceId: cameraId }),\r\n                        ...(!cameraId && { facingMode }),\r\n                    },\r\n                    target: scannerRef.current,\r\n                    willReadFrequently: true,\r\n                },\r\n                locator,\r\n                decoder: { readers: decoders },\r\n                locate,\r\n            }, async (err) => {\r\n                Quagga.onProcessed(handleProcessed);\r\n\r\n                if (err) {\r\n                    return console.error('Error starting Quagga:', err);\r\n                }\r\n                if (scannerRef && scannerRef.current) {\r\n                    await Quagga.start();\r\n                    if (onScannerReady) {\r\n                        onScannerReady();\r\n                    }\r\n                }\r\n            });\r\n            Quagga.onDetected(errorCheck);\r\n        };\r\n        init();\r\n        // cleanup by turning off the camera and any listeners\r\n        return () => {\r\n            ignoreStart = true;\r\n            Quagga.stop();\r\n            Quagga.offDetected(errorCheck);\r\n            Quagga.offProcessed(handleProcessed);\r\n        };\r\n    }, [cameraId, onDetected, onScannerReady, scannerRef, errorCheck, constraints, locator, decoders, locate, facingMode]);\r\n    return null;\r\n}\r\n\r\nScanner.propTypes = {\r\n    onDetected: PropTypes.func.isRequired,\r\n    scannerRef: PropTypes.object.isRequired,\r\n    onScannerReady: PropTypes.func,\r\n    cameraId: PropTypes.string,\r\n    facingMode: PropTypes.string,\r\n    constraints: PropTypes.object,\r\n    locator: PropTypes.object,\r\n    decoders: PropTypes.array,\r\n    locate: PropTypes.bool,\r\n};\r\n\r\nexport default Scanner;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}